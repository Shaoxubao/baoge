    回文排列。给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。
    回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。回文串不一定是字典当中的单词。

    解法1
    可以轻而易举地实现该算法。使用散列表统计每个字符出现的次数。
    然后，遍历散列表以便确定出现奇数次的字符不超过一个。

    解法2
    任何算法都要遍历整个字符串，因此，无法对时间复杂度再进行优化，但可稍作优化。
    因为该题目相对简单，所以有必要对其稍作优化或调整。可以在遍历的同时检查是否有字符只出现了奇数次，
    而不需要在遍历结束时再进行检查。因此，在一次遍历结束时，我们即有了答案。

    解法3
    如果你能更深入地思考该问题，或许会注意到字符出现的个数无关紧要。重要的是，字符出现是偶数次还是奇数次。
    你可以将其想象为开灯与关灯的操作（初始状态下灯是关着的）。如果灯最后是关闭状态，
    并不需要知道对其进行了多少次的开关操作，只需知道操作的次数是偶数次的。
    因此，可以在本题中使用一个整数数值（或者位向量）。每当看到一个字符，
    就将其映射到0与26之间的一个数值（假设所有字符都是英语字母），然后切换该数值对应的比特位。
    在遍历结束后，需要检查是否最多只有一个比特位被置为1。判断整数数值中没有比特位为1易如反掌，
    只需将整数数值与0进行比较。判断整数数值中是否刚好有一个比特位为1，则有一个很巧妙的办法。
    例如有一个整数数值00010000。我们当然可以通过重复的移位操作判断是否只有一个比特位为1。
    另一种方法是，如果将该数字减1，则会得到00001111。
    可以发现，这两个数字之间比特位没有重叠（而对于00101000，将其减1会得到00100111，比特位发生了重叠）。
    因此，判断一个数是否刚好有一个比特位为1，可以通过将其减1的结果与该数本身进行与操作，
    如果其结果为0，则比特位中1刚好出现一次。